import tkinter as tk
from tkinter import filedialog, messagebox, colorchooser, simpledialog
from tkinter.scrolledtext import ScrolledText
from tkinter import ttk
from PIL import Image, ImageTk, ImageDraw
import pytesseract
import cv2
import os
from fpdf import FPDF
from docx import Document
from docx.enum.text import WD_COLOR_INDEX
from docx.shared import Pt
from deep_translator import GoogleTranslator

# --- Setup folders and tesseract path (update if needed) ---
os.makedirs("output", exist_ok=True)
try:
    pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR\tesseract.exe'
except Exception:
    pass  # assume it's in PATH

# --- Globals ---
uploaded_image_path = ""
original_text = ""
translated_text = ""  # holds the currently translated text (if any)

# --- Helpers for Text formatting tags mapping ---
def add_tag_to_selection(tag_name, **tag_config):
    """Add a tag to the currently selected text in text_box with config (bg, font, etc)."""
    try:
        sel_start = text_box.index("sel.first")
        sel_end = text_box.index("sel.last")
    except tk.TclError:
        messagebox.showwarning("Selection", "Please select text to apply formatting.")
        return
    # If tag doesn't exist, configure it
    if tag_name not in text_box.tag_names():
        text_box.tag_config(tag_name, **tag_config)
    text_box.tag_add(tag_name, sel_start, sel_end)

def remove_tag_from_selection(tag_name):
    try:
        sel_start = text_box.index("sel.first")
        sel_end = text_box.index("sel.last")
    except tk.TclError:
        return
    text_box.tag_remove(tag_name, sel_start, sel_end)

# --- UI action functions ---
def upload_image():
    global uploaded_image_path
    path = filedialog.askopenfilename(filetypes=[("Image files", "*.png *.jpg *.jpeg *.bmp")])
    if not path:
        return
    uploaded_image_path = path
    show_image_small(path)
    text_box.delete("1.0", tk.END)
    # reset stored texts
    global original_text, translated_text
    original_text = ""
    translated_text = ""

def show_image_small(path):
    """Show a small thumbnail of the uploaded image so text area stays visible."""
    try:
        img = Image.open(path)
        img.thumbnail((160, 160))  # very small preview
        tk_img = ImageTk.PhotoImage(img)
        preview_label.configure(image=tk_img)
        preview_label.image = tk_img
    except Exception as e:
        messagebox.showerror("Image Error", f"Could not load image: {e}")

def capture_image():
    global uploaded_image_path
    cap = cv2.VideoCapture(0)
    if not cap.isOpened():
        messagebox.showerror("Webcam", "Cannot access webcam.")
        return
    messagebox.showinfo("Webcam", "Press SPACE to capture, ESC to cancel.")
    while True:
        ret, frame = cap.read()
        if not ret:
            break
        cv2.imshow("Capture - press SPACE to capture", frame)
        key = cv2.waitKey(1)
        if key % 256 == 27:  # ESC
            break
        elif key % 256 == 32:  # SPACE
            save_path = "output/captured.png"
            cv2.imwrite(save_path, frame)
            uploaded_image_path = save_path
            show_image_small(save_path)
            text_box.delete("1.0", tk.END)
            break
    cap.release()
    cv2.destroyAllWindows()

def extract_text():
    global original_text, translated_text
    translated_text = ""
    if not uploaded_image_path:
        messagebox.showwarning("No Image", "Please upload or capture an image first.")
        return
    try:
        img = Image.open(uploaded_image_path)
        lang = ocr_language.get()
        original_text = pytesseract.image_to_string(img, lang=lang)
        text_box.delete("1.0", tk.END)
        text_box.insert(tk.END, original_text)
        word_count = len(original_text.split())
        char_count = len(original_text)
        messagebox.showinfo("OCR Done", f"Extracted {word_count} words, {char_count} characters.")
    except Exception as e:
        messagebox.showerror("OCR Error", str(e))

def translate_text():
    global translated_text
    current = text_box.get("1.0", tk.END).strip()
    if not current:
        messagebox.showwarning("No Text", "No text to translate.")
        return
    try:
        dest = translate_language.get()
        translated_text = GoogleTranslator(source='auto', target=dest).translate(current)
        text_box.delete("1.0", tk.END)
        text_box.insert(tk.END, translated_text)
        messagebox.showinfo("Translated", f"Translated to {dest}.")
    except Exception as e:
        messagebox.showerror("Translate Error", str(e))

# --- Text formatting toolbar actions ---
def toggle_bold():
    apply_toggle_tag("bold", font_weight="bold")

def toggle_italic():
    apply_toggle_tag("italic", slant="italic")

def toggle_underline():
    apply_toggle_tag("underline", underline=1)

def highlight_selection():
    color = colorchooser.askcolor(title="Pick highlight color")[1]  # hex string
    if not color:
        return
    tag_name = f"highlight_{color.replace('#','')}"
    add_tag_to_selection(tag_name, background=color)

def apply_toggle_tag(tag_name, **tag_font):
    """Toggle tag on selection. If selection already has tag, remove it; else add it."""
    try:
        sel_start = text_box.index("sel.first")
        sel_end = text_box.index("sel.last")
    except tk.TclError:
        messagebox.showwarning("Selection", "Please select text first.")
        return
    current_tags = text_box.tag_names("sel.first")
    if tag_name in current_tags:
        text_box.tag_remove(tag_name, sel_start, sel_end)
    else:
        if tag_name == "bold":
            text_box.tag_config("bold", font=(display_font_family.get(), int(display_font_size.get()), "bold"))
        elif tag_name == "italic":
            text_box.tag_config("italic", font=(display_font_family.get(), int(display_font_size.get()), "italic"))
        elif tag_name == "underline":
            text_box.tag_config("underline", underline=1)
        text_box.tag_add(tag_name, sel_start, sel_end)

def set_font_family(event=None):
    fam = display_font_family.get()
    size = int(display_font_size.get())
    text_box.configure(font=(fam, size))

def set_font_size(event=None):
    set_font_family()

# --- Search & highlight within text widget ---
def search_highlight():
    query = search_entry.get().strip()
    text_box.tag_remove("search_highlight", "1.0", tk.END)
    if not query:
        return
    idx = "1.0"
    while True:
        idx = text_box.search(query, idx, nocase=1, stopindex=tk.END)
        if not idx:
            break
        end = f"{idx}+{len(query)}c"
        text_box.tag_add("search_highlight", idx, end)
        idx = end
    text_box.tag_config("search_highlight", background="yellow", foreground="black")

# --- Convert text widget contents (with tags) to a Word doc preserving formatting ---
def save_as_word():
    text_to_save = text_box.get("1.0", tk.END).rstrip("\n")
    if not text_to_save.strip():
        messagebox.showwarning("No Text", "Nothing to save.")
        return
    save_path = filedialog.asksaveasfilename(defaultextension=".docx", filetypes=[("Word doc", "*.docx")])
    if not save_path:
        return
    try:
        doc = Document()
        lines = text_to_save.split("\n")
        for i, line in enumerate(lines):
            p = doc.add_paragraph()
            if line == "" and i != len(lines)-1:
                continue
            col = 0
            buff = ""
            current_tags = None
            for ch_index in range(len(line)+1):  # +1 to flush last run
                pos = f"{i+1}.{col}"
                if ch_index < len(line):
                    ch = line[ch_index]
                    next_tags = tuple(text_box.tag_names(pos))
                    col += 1
                    buff += ch
                else:
                    next_tags = ()
                if current_tags is None:
                    current_tags = next_tags
                if next_tags != current_tags:
                    run = p.add_run(buff)
                    apply_tags_to_run(run, current_tags)
                    buff = ""
                    current_tags = next_tags
        doc.save(save_path)
        messagebox.showinfo("Saved", f"Word saved to {save_path}")

        # --- Upload to Google Drive ---
        uploaded = upload_to_drive(save_path, title=os.path.basename(save_path),
                                   mimetype="application/vnd.openxmlformats-officedocument.wordprocessingml.document")
        if uploaded:
            link = uploaded.get('webViewLink') or uploaded.get('alternateLink') or "(link unavailable)"
            messagebox.showinfo("Drive Upload", f"Uploaded to My Drive.\nFile ID: {uploaded['id']}\nLink: {link}")

    except Exception as e:
        messagebox.showerror("Save Error", str(e))

def apply_tags_to_run(run, tags):
    """Given a python-docx run and tags tuple from text widget, apply bold/italic/underline/highlight."""
    if not tags:
        return
    tags_set = set(tags)
    if "bold" in tags_set:
        run.bold = True
    if "italic" in tags_set:
        run.italic = True
    if "underline" in tags_set:
        run.underline = True
    for t in tags_set:
        if t.startswith("highlight_"):
            try:
                run.font.highlight_color = WD_COLOR_INDEX.YELLOW
            except Exception:
                pass

# --- Save as PDF (plain text) ---
def save_as_pdf():
    text_to_save = text_box.get("1.0", tk.END).strip()
    if not text_to_save:
        messagebox.showwarning("No Text", "Nothing to save.")
        return
    path = filedialog.asksaveasfilename(defaultextension=".pdf", filetypes=[("PDF", "*.pdf")])
    if not path:
        return
    try:
        pdf = FPDF()
        pdf.add_page()
        pdf.set_auto_page_break(auto=True, margin=15)
        size = int(display_font_size.get())
        pdf.set_font("Arial", size=size)
        for line in text_to_save.split("\n"):
            pdf.multi_cell(0, size+2, line)
        pdf.output(path)
        messagebox.showinfo("Saved", f"PDF saved to {path}")

        # --- Upload to Google Drive ---
        uploaded = upload_to_drive(path, title=os.path.basename(path), mimetype="application/pdf")
        if uploaded:
            link = uploaded.get('webViewLink') or uploaded.get('alternateLink') or "(link unavailable)"
            messagebox.showinfo("Drive Upload", f"Uploaded to My Drive.\nFile ID: {uploaded['id']}\nLink: {link}")

    except Exception as e:
        messagebox.showerror("PDF Error", str(e))

# --- Save as TXT ---
def save_as_txt():
    text_to_save = text_box.get("1.0", tk.END).strip()
    if not text_to_save:
        messagebox.showwarning("No Text", "Nothing to save.")
        return
    path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text", "*.txt")])
    if not path:
        return
    try:
        with open(path, "w", encoding="utf-8") as f:
            f.write(text_to_save)
        messagebox.showinfo("Saved", f"Text saved to {path}")

        # --- Upload to Google Drive ---
        uploaded = upload_to_drive(path, title=os.path.basename(path), mimetype="text/plain")
        if uploaded:
            link = uploaded.get('webViewLink') or uploaded.get('alternateLink') or "(link unavailable)"
            messagebox.showinfo("Drive Upload", f"Uploaded to My Drive.\nFile ID: {uploaded['id']}\nLink: {link}")

    except Exception as e:
        messagebox.showerror("TXT Error", str(e))

# --- Image annotation window ---
def annotate_image():
    if not uploaded_image_path:
        messagebox.showwarning("No Image", "Upload or capture an image first.")
        return
    ann = tk.Toplevel(root)
    ann.title("Annotate Image - draw with mouse (left drag). Right click to save.")
    pil_img = Image.open(uploaded_image_path).convert("RGBA")
    display_img = pil_img.copy()
    display_img.thumbnail((800, 800))
    tk_img = ImageTk.PhotoImage(display_img)
    canvas = tk.Canvas(ann, width=tk_img.width(), height=tk_img.height(), bg="white")
    canvas.pack()
    canvas.create_image(0, 0, anchor="nw", image=tk_img)

    draw = ImageDraw.Draw(display_img)
    last = None
    color = "red"
    width = 3

    def start_draw(e):
        nonlocal last
        last = (e.x, e.y)
    def draw_move(e):
        nonlocal last
        if last:
            canvas.create_line(last[0], last[1], e.x, e.y, fill=color, width=width)
            draw.line([last, (e.x, e.y)], fill=color, width=width)
            last = (e.x, e.y)
    def end_draw(e):
        nonlocal last
        last = None
    def save_and_close(e=None):
        out_path = "output/annotated.png"
        display_img.save(out_path)
        messagebox.showinfo("Saved", f"Annotated image saved to {out_path}")
        ann.destroy()

    canvas.bind("<Button-1>", start_draw)
    canvas.bind("<B1-Motion>", draw_move)
    canvas.bind("<ButtonRelease-1>", end_draw)
    ann.bind("<Button-3>", lambda ev: save_and_close())

    ann.mainloop()

# --- Search in text box ---
def search_box():
    query = search_entry.get().strip()
    text_box.tag_remove("search_match", "1.0", tk.END)
    if not query:
        return
    idx = "1.0"
    while True:
        idx = text_box.search(query, idx, nocase=1, stopindex=tk.END)
        if not idx:
            break
        end = f"{idx}+{len(query)}c"
        text_box.tag_add("search_match", idx, end)
        idx = end
    text_box.tag_config("search_match", background="yellow", foreground="black")

# --- GUI Construction (preserve your layout) ---
root = tk.Tk()
root.title("Smart Document Scanner with OCR - Phase 14 + Drive Upload")
root.geometry("980x820")
root.configure(bg="#f2f2f2")

# Top: title, small preview and text area
title_label = tk.Label(root, text="Smart Document Scanner with OCR", font=("Arial", 18, "bold"), bg="#f2f2f2")
title_label.pack(side=tk.TOP, pady=8)

preview_label = tk.Label(root, bg="#f2f2f2")
preview_label.pack(side=tk.TOP, pady=4)

# Text box (big) - keep same look
text_box = ScrolledText(root, height=12, width=110, font=("Courier", 11), wrap=tk.WORD)
text_box.pack(side=tk.TOP, padx=10, pady=6, fill=tk.BOTH, expand=False)

# Search row (small)
search_frame = tk.Frame(root, bg="#f2f2f2")
search_frame.pack(side=tk.TOP, pady=4)
search_entry = tk.Entry(search_frame, width=40)
search_entry.pack(side=tk.LEFT, padx=4)
tk.Button(search_frame, text="Search & Highlight", command=search_box, width=18).pack(side=tk.LEFT, padx=4)

# Controls (centered) use a frame like your previous layout
controls_frame = tk.Frame(root, bg="#e0e0e0")
controls_frame.pack(side=tk.TOP, pady=10, padx=10)

# Row 0
tk.Button(controls_frame, text="Upload Image", width=20, command=upload_image).grid(row=0, column=0, padx=8, pady=6)
tk.Button(controls_frame, text="Capture from Webcam", width=20, command=capture_image).grid(row=0, column=1, padx=8, pady=6)

# Row 1
tk.Button(controls_frame, text="Extract Text", width=20, command=extract_text).grid(row=1, column=0, padx=8, pady=6)
tk.Button(controls_frame, text="Annotate Image", width=20, command=annotate_image).grid(row=1, column=1, padx=8, pady=6)

# Row 2
tk.Button(controls_frame, text="Save as TXT", width=20, command=save_as_txt).grid(row=2, column=0, padx=8, pady=6)
tk.Button(controls_frame, text="Save as PDF", width=20, command=save_as_pdf).grid(row=2, column=1, padx=8, pady=6)

# Row 3
tk.Button(controls_frame, text="Save as Word", width=20, command=save_as_word).grid(row=3, column=0, padx=8, pady=6)
tk.Button(controls_frame, text="Open Output Folder", width=20,
          command=lambda: os.startfile(os.path.abspath("output"))).grid(row=3, column=1, padx=8, pady=6)

# Row 4 - formatting toolbar (centered)
toolbar_frame = tk.Frame(root, bg="#f2f2f2")
toolbar_frame.pack(side=tk.TOP, pady=8)

tk.Button(toolbar_frame, text="Bold", width=10, command=toggle_bold).grid(row=0, column=0, padx=6)
tk.Button(toolbar_frame, text="Italic", width=10, command=toggle_italic).grid(row=0, column=1, padx=6)
tk.Button(toolbar_frame, text="Underline", width=10, command=toggle_underline).grid(row=0, column=2, padx=6)
tk.Button(toolbar_frame, text="Highlight", width=12, command=highlight_selection).grid(row=0, column=3, padx=6)

# Font selectors
display_font_family = tk.StringVar(value="Courier")
display_font_size = tk.StringVar(value="11")
tk.Label(toolbar_frame, text="Font:", bg="#f2f2f2").grid(row=1, column=0, sticky="e")
fam_cb = ttk.Combobox(toolbar_frame, textvariable=display_font_family,
                      values=["Courier", "Arial", "Times New Roman"], width=18)
fam_cb.grid(row=1, column=1, padx=6)
fam_cb.bind("<<ComboboxSelected>>", set_font_family)
tk.Label(toolbar_frame, text="Size:", bg="#f2f2f2").grid(row=1, column=2, sticky="e")
size_entry = tk.Entry(toolbar_frame, width=6, textvariable=display_font_size)
size_entry.grid(row=1, column=3, padx=6)
size_entry.bind("<Return>", set_font_size)
tk.Button(toolbar_frame, text="Apply Font", command=set_font_family).grid(row=1, column=4, padx=6)

# Row 5 - OCR language, Translate (keeps layout)
options_frame = tk.Frame(root, bg="#f2f2f2")
options_frame.pack(side=tk.TOP, pady=8)

ocr_language = tk.StringVar(value="eng")
tk.Label(options_frame, text="OCR Language:", bg="#f2f2f2").grid(row=0, column=0, sticky="e")
tk.OptionMenu(options_frame, ocr_language, "eng", "hin", "tel", "tam").grid(row=0, column=1, padx=6)

translate_language = tk.StringVar(value="te")
tk.Label(options_frame, text="Translate to:", bg="#f2f2f2").grid(row=0, column=2, sticky="e")
tk.OptionMenu(options_frame, translate_language, "hi", "te", "ta", "en").grid(row=0, column=3, padx=6)

tk.Button(options_frame, text="Translate Text", width=16, command=translate_text)\
    .grid(row=1, column=0, columnspan=2, pady=6)

# Run the app
root.mainloop()
